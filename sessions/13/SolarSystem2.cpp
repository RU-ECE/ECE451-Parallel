#include <chrono>
#include <cmath>
#include <fstream>
#include <iostream>
#include <numbers>
#include <random>
#include <sstream>
#include <string>
#include <unistd.h>
#include <unordered_map>
#include <vector>

using namespace std;
using namespace numbers;

/**
 * Cleaner Object-Oriented Approach
 *
 * Create a GravSim class that contains the bodies and the simulation parameters.
 *
 * We will create a method initialize_circular, which will compute the average distance from the sun and calculate the
 * velocity for a circular orbit. We will also create a method initialize_elliptical, which will compute the average
 * distance from the sun and calculate the velocity for an elliptical orbit, but still only 2D with z = 0 to keep things
 * simple. To be in an elliptical orbit, we need to calculate the initial velocity using the vis-viva equation, which I
 * do not know, but thankfully ChatGPT does. Go ahead, ChatGPT: explain the vis-viva equation to me. The vis-viva
 * equation is a formula used to describe the motion of a body in a gravitational field. It relates the speed of an
 * orbiting body to its distance from the central body. The equation is v = sqrt(GM(2/r - 1/a)) where v is the speed of
 * the orbiting body, G is the gravitational constant, M is the mass of the central body, r is the distance between the
 * orbiting body and the central body, and a is the semi-major axis of the orbit.
 *
 * add_body_circular is a method that adds a body to the system used internally by initialize_circular.
 *
 * add_body_elliptical is a method that adds a body to the system used internally by the initialize_elliptical code,
 * which is shared by both. This method can be put in add_body. These three methods are private to the class.
 *
 * We will load the data from a file (solarsystem.dat, which was generated by hand but augmented by ChatGPT to include
 * many more bodies). Thanks, ChatGPT! Note that I typed that, and ChatGPT thanked itself there.
 *
 * All values of each body are stored in a single struct, and there is only a single vector of body structs.
 *
 * You can rearrange into separate vectors if you wish; it might be more performant. There is only one way to find out!
 *
 * compute_acceleration is a method that computes the acceleration of each body.
 *
 * step_forward advances velocity and position using a simple forward Euler method.
 *
 * print_system is a method that prints the state of the system.
 *
 * The cleanest way to graph this would be to output a text file and call either MATLAB or Python. Possibly even use a
 * socket connection to do it directly, but that is too much work for now. graph_system() is a method that graphs the
 * system using the matplotlib library.
 */

constexpr double year = 365.25 * 24 * 60 * 60;
constexpr float G = 6.67e-11;
random_device rd;
mt19937 gen(0); // seed the generator with 0 for testing, this way we get the same results every time
// Kruger's rule of testing: only use real random numbers once it works
uniform_real_distribution<> dis(0, 1);

constexpr auto print_every = 100;
constexpr auto graph_every = 1000;

class GravSim {
public:
	bool verbose;
	enum class configuration { CIRCULAR, ELLIPTICAL_2D, CIRCULAR_RANDOM, ELLIPTICAL_3D }; // not doing 3D for now.
private:
	ofstream graphfile;
	vector<string> names;
	unordered_map<string, unsigned int> orbit_map;
	unsigned int find(const string& orbits) {
		const auto it = orbit_map.find(orbits);
		return it == orbit_map.end() ? 0 // defaults to the sun
									 : it->second;
	}
	struct body {
		unsigned int id; // unique identifier, let's keep strings out of the struct
		float Gm, // precomputed G*m
			x, y, z, // position
			vx, vy, vz, // velocity
			ax, ay, az, // acceleration
			old_ax, old_ay, old_az; // old acceleration
		void accelerate(const float ax, const float ay, const float az) {
			this->ax += ax;
			this->ay += ay;
			this->az += az;
		}
	};
	vector<body> bodies; // everything is in a vector for easy parallelization
	float dt;
	unsigned long timestep;
	int num_steps;
	static void read_line(ifstream& infile) {}

	void add_body(const string& name, unsigned int orbiting_body, const float m, const float x, const float y,
				  const float z, const float vx, const float vy, const float vz) {
		bodies.push_back({static_cast<unsigned int>(names.size()), G * m, x, y, z, vx, vy, vz, 0, 0, 0, 0, 0, 0});
		names.push_back(name);
	}
	void add_body_circular(const string& name, unsigned int orbiting_body, float m, float a, float e, float orbPeriod);
	void add_body_circular_random(const string& name, unsigned int orbiting_body, float m, float a, float e,
								  float orbPeriod);
	void add_body_elliptical(const string& name, unsigned int orbiting_body, float m, float a, float e,
							 float orbPeriod);

public:
	GravSim(const char filename[], float dt, float duration, bool verbose, unsigned int print_every,
			unsigned int graph_every, configuration config);
	~GravSim(); // we probably don't need a destructor, but we can just make it empty for now
	GravSim(const GravSim& orig) =
		delete; // let's stop people from accidentally copying the system, it can be enormous!
	GravSim& operator=(const GravSim& rhs) = delete;
	void read_line(ifstream& infile, configuration config);
	void compute_acceleration();
	void step_forward();
	void print_system() const;
	void graph_system();
};

/*
 * Calculates the initial velocity for simple circular orbits around the specified body
 * This method will line up all bodies initially on the x-axis which is kind of dumb.
 * The next option below is circular but starts everyone at a random angle.
 */
void GravSim::add_body_circular(const string& name, const unsigned int orbiting_body, const float m, const float a,
								float e, const float orbPeriod) {
	const auto Gm = bodies[orbiting_body].Gm;
	auto v0 = sqrt(Gm / a); // assuming the sun's mass for simplicity
	if (orbPeriod < 0)
		v0 = -v0; // reverse direction for negative orbital period
	const auto x = bodies[orbiting_body].x + a; // place the new body at the aphelion
	add_body(name, orbiting_body, m, x, 0, 0, 0, v0, 0);
}

/*
 * Calculates the initial velocity for a circular orbit where each body starts at a random angle around the orbiting
 * body. We should fix this by adding a parameter to the method to specify the body being orbited. This method will
 * start everyone at a random angle.
 */
void GravSim::add_body_circular_random(const string& name, const unsigned int orbiting_body, const float m,
									   const float a, float e, const float orbPeriod) {
	auto v0 = sqrt(bodies[orbiting_body].Gm / a); // assuming the sun's mass for simplicity
	if (orbPeriod < 0)
		v0 = -v0; // reverse direction for bodies moving in the opposite direction (example: Venus)
	const auto angle = dis(gen) * 2 * pi;
	const auto x = bodies[orbiting_body].x +
		a * cos(angle); // calculate the position of the new body with respect to the orbiting body
	const float y = bodies[orbiting_body].y + a * sin(angle); // for the sun, [x,y] = [0,0] initially
	add_body(name, orbiting_body, m, x, y, 0, -v0 * sin(angle), v0 * cos(angle), 0);
}

/*
 * Calculates the initial velocity for an elliptical orbit around the specified body
 * You don't have to use this for your homework, but it's kind of cool.
 */
void GravSim::add_body_elliptical(const string& name, const unsigned int orbiting_body, const float m, const float a,
								  const float e, float orbPeriod) {
	const auto Gm = bodies[orbiting_body].Gm;
	const auto v0 = sqrt(Gm * (1 - e * e) / a); // vis-viva equation
	// O great chatgpt, we will take your word for this....
	const auto angle = dis(gen) * 2 * pi;
	add_body(name, orbiting_body, m, a * cos(angle), a * sin(angle), 0, -v0 * sin(angle), v0 * cos(angle), 0);
}

GravSim::GravSim(const char filename[], const float dt, const float duration, const bool verbose,
				 unsigned int print_every, const unsigned int graph_every, const configuration config) :
	verbose(verbose), graphfile("solargraph.dat"), dt(dt), timestep(0), num_steps(duration / dt) {
	ifstream infile(filename);
	while (infile)
		read_line(infile, config);
	infile.close();
	cout << "Starting simulation with " << bodies.size() << " bodies num_steps=" << num_steps << endl;
	for (auto i = 0; i < num_steps; i++) {
		for (auto& body : bodies) { // save the old accelerations
			body.old_ax = body.ax;
			body.old_ay = body.ay;
			body.old_az = body.az;
		}
		compute_acceleration();
		step_forward();
		if (verbose) {
			timestep = i;
			// if (i % print_every == 0)
			// 	print_system();
			if (i % graph_every == 0) {
				graph_system();
				// wait for the user to press enter
				// cout << "Press enter to continue\n";
				// cin.ignore();
			}
		}
	}
}

GravSim::~GravSim() = default;

using enum GravSim::configuration;

// read a line from the file as specified in solarsystem.dat
void GravSim::read_line(ifstream& infile, const configuration config) {
	char buffer[4096];
	infile.getline(buffer, 4096);
	if (infile.fail())
		return;
	if (buffer[0] == '#')
		return; // skip comments
	if (buffer[0] == ' ' || buffer[0] == '\0')
		return; // skip blank lines
	stringstream ss(buffer);
	string name, orbits;
	float mass, diam, perihelion, aphelion, orbPeriod, rotationalPeriod, axialtilt, orbinclin;
	ss >> name >> orbits >> mass >> diam >> perihelion >> aphelion >> orbPeriod >> rotationalPeriod >> axialtilt >>
		orbinclin;
	if (bodies.empty()) {
		// we need to add the sun first
		add_body(name, 0, mass, 0, 0, 0, 0, 0, 0);
		return;
	}
	switch (config) {
	case CIRCULAR:
		add_body_circular(name, find(orbits), mass, perihelion, 0, orbPeriod);
		break;
	case CIRCULAR_RANDOM:
		add_body_circular_random(name, find(orbits), mass, perihelion, 0, orbPeriod);
		break;
	case ELLIPTICAL_2D:
		add_body_elliptical(name, find(orbits), mass, perihelion, aphelion, orbPeriod);
		break;
	case ELLIPTICAL_3D:
		// TODO: implement elliptical 3D
		break;
	}
}

/*
 * Our solver uses simple high school math
 *
 * F(m1,m2) = G*m1*m2/(d^2)
 *
 * acceleration on m1 by m2: a(m1) = f(m1,m2)/(m1) = G*m2/(d^2)
 *
 * step forward in time: (Euler's method)
 *
 * v = v + a*dt
 *
 * x = x + v*dt
 *
 * Better: Runge-Kutta Fehlberg (RKF45)
 *
 * Compute accelerations on each body. This is the most expensive part of the simulation.
 * With one core per body, we could keep acceleration in registers, but for n=10^6 that's only doable on a
 * supercomputer.
 *
 * Use OpenMP to automatically parallelize the loop over bodies, and use SIMD to parallelize the loop over the
 * particles This code will just use scalars. You may simplify your life by just truncating the list to a multiple of 8
 * bodies when you load. You may run this code for the base case. Your goal is to make yours much faster. Goog luck!
 */

void GravSim::compute_acceleration() {
	for (auto i = 0UL; i < bodies.size(); i++) {
		const auto x1 = bodies[i].x, y1 = bodies[i].y, z1 = bodies[i].z;
		auto ax0 = 0.0f, ay0 = 0.0f, az0 = 0.0f;
		for (auto j = 0UL; j < bodies.size(); j++) {
			if (i == j)
				continue;
			const auto Gm2 = bodies[j].Gm, x2 = bodies[j].x, y2 = bodies[j].y, z2 = bodies[j].z, dx = x2 - x1,
					   dy = y2 - y1, dz = z2 - z1, r2 = dx * dx + dy * dy + dz * dz, r = sqrt(r2), a_r = Gm2 / (r2 * r);
			ax0 += a_r * dx;
			ay0 += a_r * dy;
			az0 += a_r * dz;
		}
		bodies[i].accelerate(ax0, ay0, az0);
	}
	print_system();
	cin.ignore();
}

// error: vx is not constant, can do a better approximation
void GravSim::step_forward() {
	for (auto& body : bodies) {
		body.x += body.vx * dt;
		body.y += body.vy * dt;
		body.z += body.vz * dt;
		body.vx += body.ax * dt;
		body.vy += body.ay * dt;
		body.vz += body.az * dt;
	}
}

void GravSim::print_system() const {
	for (auto i = 0UL; i < bodies.size(); i++) {
		cout << names[i] << " " << bodies[i].x << " " << bodies[i].y << " " << bodies[i].z << " " << bodies[i].vx << " "
			 << bodies[i].vy << " " << bodies[i].vz << endl;
	}
}

#if 0
void GravSim::graph_system() const {
	static int pipefd[2];
	static auto pid = -1;
	if (pid == -1) { // Create the pipe and fork only once
		if (pipe(pipefd) == -1) {
			perror("pipe");
			exit(EXIT_FAILURE);
		}
		pid = fork();
		if (pid == -1) {
			perror("fork");
			exit(EXIT_FAILURE);
		}
		if (pid == 0) { // Child process
			close(pipefd[1]); // Close write end
			dup2(pipefd[0], STDIN_FILENO); // Redirect stdin to read end of pipe
			execlp("python3", "python3", "plotsolar.py", NULL);
			perror("execlp");
			exit(EXIT_FAILURE);
		} else { // Parent process
			close(pipefd[0]); // Close read end
		}
	}
	for (auto  i = 0; i < bodies.size(); i++)
		dprintf(pipefd[1], "%s %f %f %f\n", names[i].c_str(), bodies[i].x, bodies[i].y, bodies[i].z);
	dprintf(pipefd[1], "draw\n");
}
#endif

void GravSim::graph_system() {
	for (auto i = 0UL; i < bodies.size(); i++)
		graphfile << names[i] << ' ' << bodies[i].x << ' ' << bodies[i].y << ' ' << bodies[i].z << ' ';
	graphfile << endl;
}

int main(const int argc, char* argv[]) {
	GravSim sim(argc > 1 ? argv[1] : "solarsystem2.dat", 100, year, true, 10'000, 100, CIRCULAR_RANDOM);
	sim.print_system();
	sim.graph_system();
}
