#include <chrono>
#include <cmath>
#include <fstream>
#include <iostream>
#include <numbers> // for C++20 pi
#include <random>
#include <sstream>
#include <string>
#include <unistd.h>
#include <unordered_map>
#include <vector>

using namespace std;
using namespace numbers;
/*
	Cleaner Object Oriented Approach
	Create a GravSim class that contains the bodies and the simulation parameters
	We will create one method initialize_circular which will compute the average distance from the sun and calculate the
   velocity for a circular orbit. We will also create a method initialize_elliptical which will compute the average
   distance from the sun and calculate the velocity for an elliptical orbit, but still only 2D with z = 0 to keep things
   simple. In order to be in an elliptical orbit, we need to calculate the initial velocity using the vis-viva equation,
   which I don't know, but thankfully chatgpt does. GO ahead chatgpt: explain the vis-viva equation to me The vis-viva
   equation is a formula used to describe the motion of a body in a gravitational field. It relates the speed of an
   orbiting body to its distance from the central body. The equation is: v = sqrt(GM(2/r - 1/a)) where: v is the speed
   of the orbiting body G is the gravitational constant M is the mass of the central body r is the distance between the
   orbiting body and the central body a is the semi-major axis of the orbit

	add_body_circular is a method that adds a body to the system used internally by initialize_circular
	add_body_elliptical is a method that adds a body to the system used internally by initialize_elliptical
	code shared by both can be put in add_body. These three methods are private to the class.

	we will load the data from a file (solarsystem.dat is generated by hand, but chatgpt augmented it to include many
   more bodies. Thanks chatgpt! Note, that I typeed Tha and chatgpt thanked itself there.

	all values of each body are stored in a struct together, there is only a single vector of body structs
	You can rearrange into separate vectors if you wish, it might be more performant. There's only one way to find out!

	compute_acceleration is a method that computes the acceleration of each body
	step_forward advances velocity and position using a simple forward Euler method
	print_system is a method that prints the state of the system
	The cleanest way to graph this would be to output a text file and call either MATLAB or python. Possibly even use a
   socket connection to do it directly but that's too much work for now. graph_system() is a method that graphs the
   system using matplotlib.
*/

constexpr double year = 365.25 * 24 * 60 * 60;
constexpr float G = 6.67e-11;
random_device rd;
mt19937 gen(0); // seed the generator with 0 for testing, this way we get the same results every time
// Kruger's rule of testing: only use real random numbers once it works
uniform_real_distribution<> dis(0, 1);

constexpr auto print_every = 100;
constexpr auto graph_every = 1000;

class GravSim {
public:
	bool verbose;
	enum class configuration { CIRCULAR, ELLIPTICAL_2D, CIRCULAR_RANDOM, ELLIPTICAL_3D }; // not doing 3D for now.
private:
	ofstream graphfile;
	vector<string> names;
	unordered_map<string, uint32_t> orbit_map;
	uint32_t find(const string& orbits) {
		const auto it = orbit_map.find(orbits);
		if (it == orbit_map.end())
			return 0; // default to the sun
		return it->second;
	}
	struct body {
		uint32_t id; // unique identifier, let's keep strings out of the struct
		float Gm; // precomputed G*m
		float x, y, z; // position
		float vx, vy, vz; // velocity
		float ax, ay, az; // acceleration
		float old_ax, old_ay, old_az; // old acceleration
		void accelerate(const float ax, const float ay, const float az) {
			this->ax += ax;
			this->ay += ay;
			this->az += az;
		}
	};
	vector<body> bodies; // everything is in a vector for easy parallelization
	float dt;
	uint64_t timestep;
	int num_steps;
	void read_line(ifstream& infile);

	void add_body(const string& name, uint32_t orbiting_body, const float m, const float x, const float y,
				  const float z, const float vx, const float vy, const float vz) {
		bodies.push_back({static_cast<uint32_t>(names.size()), G * m, x, y, z, vx, vy, vz, 0, 0, 0});
		names.push_back(name);
	}
	void add_body_circular(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod);
	void add_body_circular_random(const string& name, uint32_t orbiting_body, float m, float a, float e,
								  float orbPeriod);
	void add_body_elliptical(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod);

public:
	GravSim(const char filename[], float dt, float duration, bool verbose, uint32_t print_every, uint32_t graph_every,
			configuration config);
	~GravSim(); // we probably don't need a destructor, but we can just make it empty for now
	GravSim(const GravSim& orig) =
		delete; // let's stop people from accidentally copying the system, it can be enormous!
	GravSim& operator=(const GravSim& rhs) = delete;
	void read_line(ifstream& infile, configuration config);
	void compute_acceleration();
	void step_forward();
	void print_system() const;
	void graph_system();
};


/*
	Calculates the initial velocity for simple circular orbits around the specified body
	This method will line up all bodies initially on the x-axis which is kind of dumb.
	The next option below is circular but starts everyone at a random angle.
*/
void GravSim::add_body_circular(const string& name, const uint32_t orbiting_body, const float m, const float a, float e,
								const float orbPeriod) {
	const float Gm = bodies[orbiting_body].Gm;
	float v0 = sqrt(Gm / a); // assuming the sun's mass for simplicity
	if (orbPeriod < 0)
		v0 = -v0; // reverse direction for negative orbital period
	const float x = bodies[orbiting_body].x + a; // place the new body at the aphelion
	add_body(name, orbiting_body, m, x, 0, 0, 0, v0, 0);
}

/*
	Calculates the initial velocity for a circular orbit where each body starts at a random angle around the orbiting
   body We should fix this by adding a parameter to the method to specify the body being orbited. This method will start
   everyone at a random angle.
*/
void GravSim::add_body_circular_random(const string& name, const uint32_t orbiting_body, const float m, const float a,
									   float e, const float orbPeriod) {
	float v0 = sqrt(bodies[orbiting_body].Gm / a); // assuming the sun's mass for simplicity
	if (orbPeriod < 0)
		v0 = -v0; // reverse direction for bodies moving in the opposite direction (example: Venus)
	const float angle = dis(gen) * 2 * pi;
	const float x = bodies[orbiting_body].x +
		a * cos(angle); // calculate the position of the new body with respect to the orbiting body
	const float y = bodies[orbiting_body].y + a * sin(angle); // for the sun, [x,y] = [0,0] initially
	add_body(name, orbiting_body, m, x, y, 0, -v0 * sin(angle), v0 * cos(angle), 0);
}

/*
	Calculates the initial velocity for an elliptical orbit around the specified body
	You don't have to use this for your homework, but it's kind of cool.
*/
void GravSim::add_body_elliptical(const string& name, const uint32_t orbiting_body, const float m, const float a,
								  const float e, float orbPeriod) {
	const float Gm = bodies[orbiting_body].Gm;
	const float v0 = sqrt(Gm * (1 - e * e) / a); // vis-viva equation
	// O great chatgpt, we will take your word for this....

	const float angle = dis(gen) * 2 * pi;
	add_body(name, orbiting_body, m, a * cos(angle), a * sin(angle), 0, -v0 * sin(angle), v0 * cos(angle), 0);
}

// read a line from the file as specified in solarsystem.dat
void GravSim::read_line(ifstream& infile, const configuration config) {
	char buffer[4096];
	infile.getline(buffer, 4096);
	if (infile.fail())
		return;
	if (buffer[0] == '#')
		return; // skip comments
	if (buffer[0] == ' ' || buffer[0] == '\0')
		return; // skip blank lines
	stringstream ss(buffer);
	string name, orbits;
	float mass, diam, perihelion, aphelion, orbPeriod, rotationalPeriod, axialtilt, orbinclin;
	ss >> name >> orbits >> mass >> diam >> perihelion >> aphelion >> orbPeriod >> rotationalPeriod >> axialtilt >>
		orbinclin;
	if (bodies.size() == 0) {
		// we need to add the sun first
		add_body(name, 0, mass, 0, 0, 0, 0, 0, 0);
		return;
	}
	const uint32_t orbiting_body = find(orbits);
	if (config == configuration::CIRCULAR) {
		add_body_circular(name, orbiting_body, mass, perihelion, 0, orbPeriod);
	} else if (config == configuration::CIRCULAR_RANDOM) {
		add_body_circular_random(name, orbiting_body, mass, perihelion, 0, orbPeriod);
	} else if (config == configuration::ELLIPTICAL_2D) {
		add_body_elliptical(name, orbiting_body, mass, perihelion, aphelion, orbPeriod);
	} else if (config == configuration::ELLIPTICAL_3D) {
		// TODO: implement elliptical 3D
	}
}

GravSim::GravSim(const char filename[], const float dt, const float duration, const bool verbose, uint32_t print_every,
				 const uint32_t graph_every, const configuration config) :
	verbose(verbose), graphfile("solargraph.dat"), dt(dt), timestep(0), num_steps(duration / dt) {

	ifstream infile(filename);
	while (infile)
		read_line(infile, config);
	infile.close();
	cout << "Starting simulation with " << bodies.size() << " bodies num_steps=" << num_steps << endl;
	for (auto i = 0; i < num_steps; i++) {
		for (auto j = 0; j < bodies.size(); j++) { // save the old accelerations
			bodies[j].old_ax = bodies[j].ax;
			bodies[j].old_ay = bodies[j].ay;
			bodies[j].old_az = bodies[j].az;
		}
		compute_acceleration();
		step_forward();
		if (verbose) {
			timestep = i;
			//            if (i % print_every == 0) {
			//                print_system();
			//            }
			if (i % graph_every == 0) {
				graph_system();
				// wait for the user to press enter
				//                cout << "Press enter to continue\n";
				//                cin.ignore();
			}
		}
	}
}

GravSim::~GravSim() {}

/*
	Our solver uses simple high school math

	F(m1,m2) = G*m1*m2/(d^2)
	acceleration on m1 by m2: a(m1) = f(m1,m2)/(m1) = G*m2/(d^2)

	step forward in time: (Euler's method)
	v = v + a*dt
	x = x + v*dt

	Better: Runge-Kutta Fehlberg (RKF45)

	Compute accelerations on each body. This is the most expensive part of the simulation.
	With one core per body, we could keep acceleration in registers, but for n=10^6 that's only doable on a
   supercomputer.

	Use OpenMP to automatically parallelize the loop over bodies, and use SIMD to parallelize the loop over the
   particles This code will just use scalars. You may simplify your life by just truncating the list to a multiple of 8
   bodies when you load. You may run this code for the base case. Your goal is to make yours much faster. Goog luck!
*/

void GravSim::compute_acceleration() {
	for (auto i = 0; i < bodies.size(); i++) {
		const float x1 = bodies[i].x;
		const float y1 = bodies[i].y;
		const float z1 = bodies[i].z;
		float ax0 = 0;
		float ay0 = 0;
		float az0 = 0;
		for (auto j = 0; j < bodies.size(); j++) {
			if (i == j)
				continue;
			const float Gm2 = bodies[j].Gm;
			const float x2 = bodies[j].x;
			const float y2 = bodies[j].y;
			const float z2 = bodies[j].z;
			const float dx = x2 - x1;
			const float dy = y2 - y1;
			const float dz = z2 - z1;
			// calculate r^2 not r!
			const float r2 = dx * dx + dy * dy + dz * dz;
			const float r = sqrt(r2);
			const float a_r = Gm2 / (r2 * r);
			ax0 += a_r * dx;
			ay0 += a_r * dy;
			az0 += a_r * dz;
		}
		bodies[i].accelerate(ax0, ay0, az0);
	}
	print_system();
	cin.ignore();
}

// error: vx is not constant, can do a better approximation
void GravSim::step_forward() {
	for (auto i = 0; i < bodies.size(); i++) {
		bodies[i].x += bodies[i].vx * dt;
		bodies[i].y += bodies[i].vy * dt;
		bodies[i].z += bodies[i].vz * dt;
		bodies[i].vx += bodies[i].ax * dt;
		bodies[i].vy += bodies[i].ay * dt;
		bodies[i].vz += bodies[i].az * dt;
	}
}

void GravSim::print_system() const {
	for (auto i = 0; i < bodies.size(); i++) {
		cout << names[i] << " " << bodies[i].x << " " << bodies[i].y << " " << bodies[i].z << " " << bodies[i].vx << " "
			 << bodies[i].vy << " " << bodies[i].vz << endl;
	}
}
#if 0
void GravSim::graph_system() const {
    static int pipefd[2];
    static pid_t pid = -1;

    if (pid == -1) { // Create the pipe and fork only once
        if (pipe(pipefd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid == 0) { // Child process
            close(pipefd[1]); // Close write end
            dup2(pipefd[0], STDIN_FILENO); // Redirect stdin to read end of pipe
            execlp("python3", "python3", "plotsolar.py", NULL);
            perror("execlp");
            exit(EXIT_FAILURE);
        } else { // Parent process
            close(pipefd[0]); // Close read end
        }
    }

    for (int i = 0; i < bodies.size(); i++) {
        dprintf(pipefd[1], "%s %f %f %f\n", names[i].c_str(), bodies[i].x, bodies[i].y, bodies[i].z);
    }
    dprintf(pipefd[1], "draw\n");
}
#endif

void GravSim::graph_system() {
	for (auto i = 0; i < bodies.size(); i++)
		graphfile << names[i] << ' ' << bodies[i].x << ' ' << bodies[i].y << ' ' << bodies[i].z << ' ';
	graphfile << endl;
}

int main(const int argc, char** argv) {
	const char* filename = argc > 1 ? argv[1] : "solarsystem2.dat";
	GravSim sim(filename, 100, year, true, 10000, 100, GravSim::configuration::CIRCULAR_RANDOM);
	sim.print_system();
	sim.graph_system();
}
