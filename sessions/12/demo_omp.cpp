#include <cstdio>
#include <cstdlib>
#include <omp.h>

/*
	1 1 1 1            1 1 1 1    3
	1 1 1 1    X       1 1 1 1 =
	1 1 1 1            1 1 1 1
	1 1 1 1            1 1 1 1
*/

// dumb matrix multiply generated by COdium, writes to memory
void multiplymatrix(const float a[], const float b[], float c[], const int n) {
	for (auto i = 0; i < n; i++) {
		for (auto j = 0; j < n; j++) {
			c[i * n + j] = 0.0;
			for (auto k = 0; k < n; k++)
				c[i * n + j] += a[i * n + k] * b[k * n + j];
		}
	}
}

// inner dot product uses registers, still goes in
// non-sequential direction in memory
void multiplymatrix2(const float a[], const float b[], float c[], const int n) {
	for (auto i = 0; i < n; i++) {
		for (auto j = 0; j < n; j++) {
			auto dot = 0.0f;
			for (auto k = 0; k < n; k++)
				dot += a[i * n + k] * b[k * n + j];
			c[i * n + j] = dot;
		}
	}
}

// HW: make a better matrix multiply where second matrix is transposed

/*
	MANY PARTITIONING SCHEMES
	alternate i between threads

	blocks of rows

	for n=1024, 4 threads, each thread does 256 rows
*/

// multithreading with OpenMP
void multiplymatrix3(const float a[], const float b[], float c[], const int n) {
#pragma omp parallel for
	for (auto i = 0; i < n; i++) {
		for (auto j = 0; j < n; j++) {
			auto dot = 0.0f;
			for (auto k = 0; k < n; k++)
				dot += a[i * n + k] * b[k * n + j];
			c[i * n + j] = dot;
		}
	}
}

// parallel for, inner loop?
// general rule, for multithreading try to do the biggest outer loop
// for simd, try to do the innermost loop
void multiplymatrix3b(const float a[], const float b[], float c[], const int n) {
	for (auto i = 0; i < n; i++) {
		for (auto j = 0; j < n; j++) {
			auto dot = 0.0f;
#pragma omp parallel for reduction(+ : dot)
			for (auto k = 0; k < n; k++)
				dot += a[i * n + k] * b[k * n + j];
			c[i * n + j] = dot;
		}
	}
}

// combine multithreading and simd
void multiplymatrix4(const float a[], const float b[], float c[], const int n) {
#pragma omp parallel for
	for (auto i = 0; i < n; i++) {
		for (auto j = 0; j < n; j++) {
			auto dot = 0.0f;
#pragma omp simd
			for (auto k = 0; k < n; k++)
				dot += a[i * n + k] * b[k * n + j];
			c[i * n + j] = dot;
		}
	}
}

int main(const int argc, char* argv[]) {
	const auto num_threads = omp_get_num_procs();
	printf("Number of processors available: %d\n", num_threads);
	const auto n = argc > 1 ? strtol(argv[1], nullptr, 10) : 256;
	const auto a = new float[n * n];
	const auto b = new float[n * n];
	const auto c = new float[n * n];

	// set the matrices to random values
	for (auto i = 0; i < n * n; i++) {
		a[i] = 1;
		b[i] = 1;
		c[i] = 0;
	}
#if 0
    auto t0 = omp_get_wtime();
    multiplymatrix(a, b, c, n);
    auto t1 = omp_get_wtime();
    printf("Time multiplymatrix: %f seconds\n", t1 - t0);

    t0 = omp_get_wtime();
    multiplymatrix2(a, b, c, n);
    t1 = omp_get_wtime();
    printf("Time multiplymatrix2: %f seconds\n", t1 - t0);
#endif
	auto t0 = omp_get_wtime();
	multiplymatrix3(a, b, c, n);
	auto t1 = omp_get_wtime();
	printf("Time multiplymatrix3: %f seconds\n", t1 - t0);

	t0 = omp_get_wtime();
	multiplymatrix4(a, b, c, n);
	t1 = omp_get_wtime();
	printf("Time multiplymatrix4: %f seconds\n", t1 - t0);

	delete[] a;
	delete[] b;
	delete[] c;
	return 0;
}
