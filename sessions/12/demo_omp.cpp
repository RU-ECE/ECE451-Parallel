#include <omp.h>
#include <cstdio>
#include <cstdlib>

/*
    1 1 1 1            1 1 1 1    3
    1 1 1 1    X       1 1 1 1 =  
    1 1 1 1            1 1 1 1
    1 1 1 1            1 1 1 1


*/


// dumb matrix multiply generated by COdium, writes to memory
void multiplymatrix(float a[], float b[], float c[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            c[i * n + j] = 0.0;
            for (int k = 0; k < n; k++) {
                c[i * n + j] += a[i * n + k] * b[k * n + j];
            }
        }
    }
}


// inner dot product uses registers, still goes in
// non-sequential direction in memory
void multiplymatrix2(float a[], float b[], float c[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            float dot = 0.0;
            for (int k = 0; k < n; k++) {
                dot += a[i * n + k] * b[k * n + j];
            }
            c[i * n + j] = dot;
        }
    }
}

// HW: make a better matrix multiply where second matrix is transposed

/*
    MANY PARTITIONING SCHEMES
    alternate i between threads

    blocks of rows

    for n=1024, 4 threads, each thread does 256 rows
*/


// multithreading with OpenMP
void multiplymatrix3(float a[], float b[], float c[], int n) {

    #pragma omp parallel for
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            float dot = 0.0;
            for (int k = 0; k < n; k++) {
                dot += a[i * n + k] * b[k * n + j];
            }
            c[i * n + j] = dot;
        }
    }
}

// parallel for, inner loop?
// general rule, for multithreading try to do the biggest outer loop
// for simd, try to do the innermost loop
void multiplymatrix3b(float a[], float b[], float c[], int n) {

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            float dot = 0.0;
    #pragma omp parallel for reduction(+:dot)
            for (int k = 0; k < n; k++) {
                dot += a[i * n + k] * b[k * n + j];
            }
            c[i * n + j] = dot;
        }
    }
}


/*
    combine multithreading and simd
*/ 
void multiplymatrix4(float a[], float b[], float c[], int n) {

    #pragma omp parallel for
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            float dot = 0.0;
            #pragma omp simd
            for (int k = 0; k < n; k++) {
                dot += a[i * n + k] * b[k * n + j];
            }
            c[i * n + j] = dot;
        }
    }
}


int main(int argc, char* argv[]) {
    int num_threads = omp_get_num_procs();
    printf("Number of processors available: %d\n", num_threads);
    const int n = argc > 1 ? atoi(argv[1]) : 256;
    float* a = new float[n*n];
    float* b = new float[n*n];
    float* c = new float[n*n];

    // set the matrices to random values
    for (int i = 0; i < n*n; i++) {
        a[i] = 1;
        b[i] = 1;
        c[i] = 0;
    }
#if 0
    auto t0 = omp_get_wtime();
    multiplymatrix(a, b, c, n);
    auto t1 = omp_get_wtime();
    printf("Time multiplymatrix: %f seconds\n", t1 - t0);

    t0 = omp_get_wtime();
    multiplymatrix2(a, b, c, n);
    t1 = omp_get_wtime();
    printf("Time multiplymatrix2: %f seconds\n", t1 - t0);
#endif
    auto t0 = omp_get_wtime();
    multiplymatrix3(a, b, c, n);
    auto t1 = omp_get_wtime();
    printf("Time multiplymatrix3: %f seconds\n", t1 - t0);

    t0 = omp_get_wtime();
    multiplymatrix4(a, b, c, n);
    t1 = omp_get_wtime();
    printf("Time multiplymatrix4: %f seconds\n", t1 - t0);

    delete[] a;
    delete[] b;
    delete[] c;
    return 0;
}