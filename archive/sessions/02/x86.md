# x86 Architecture

## Within a Core

### Instruction Pointer

- `rip` is the instruction pointer (program counter, PC).

### Integer Registers

x86-64 has **16 general-purpose integer registers**.  
Each has 64-bit, 32-bit, 16-bit, and (for many of them) 8-bit views.

- 64-bit registers:
	- `rax`, `rbx`, `rcx`, `rdx`
	- `rsi`, `rdi`, `rbp`, `rsp`
	- `r8`, `r9`, `r10`, `r11`, `r12`, `r13`, `r14`, `r15`

- 32-bit views:
	- `eax`, `ebx`, `ecx`, `edx`, `esi`, `edi`, `ebp`, `esp`
	- `r8d`, `r9d`, `r10d`, `r11d`, `r12d`, `r13d`, `r14d`, `r15d`

(Historically there were fewer general-purpose registers in 16- and 32-bit x86; x86-64 expanded this to 16.)

---

## SIMD Extensions

### SSE

- Introduced SSE with **128-bit** SIMD registers:
	- `xmm0`, `xmm1`, …, `xmm15`
- Each `xmm` register can be treated as:
	- 1 × 128-bit value
	- 2 × 64-bit values
	- 4 × 32-bit values
	- 8 × 16-bit values
	- 16 × 8-bit values

### AVX / AVX2

- AVX/AVX2 expand SIMD registers to **256 bits**:
	- `ymm0`, `ymm1`, $\ldots$, `ymm15`
- The **low 128 bits** of `ymmN` are the same as `xmmN`.

So:

- `xmm0` is the low half of `ymm0`,
- $\ldots$
- `xmm15` is the low half of `ymm15`.

### AVX-512

- AVX-512 expands SIMD registers to **512 bits**:
	- `zmm0`, `zmm1`, $\ldots$, `zmm31`
- Each `zmm` register can hold, for example:
	- 8 × 64-bit numbers
	- 16 × 32-bit numbers, etc.

Example vector FMA-style operation (conceptual):

```text
zmm0 * zmm1 + zmm2
````

This represents elementwise multiply of `zmm0` and `zmm1`, then add `zmm2` (using 512-bit SIMD).
