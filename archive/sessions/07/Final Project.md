# Final Project

## 1. Testing

Your first job is to **prove that your project works**.

### Example: Sorting

If your project is a **sort**, you should:

- Write a function to generate a **known distribution**:
	- $1, 2, 3, \ldots, n$
	- Shuffle the $n$ numbers.
	- Sort them.
	- Verify that you still have exactly $1, 2, 3, \ldots, n$.
- You can also test with:
	- Repeated values: $1, 1, 2, 2, 3, 3, \ldots, n$

The idea: make it **impossible to “accidentally” be correct**—your tests should strongly confirm correctness.

### Compare to a Known Library

- Compare your results against a **trusted library**.
	- For sorting: standard library sort.
	- For matrices: libraries like **BLAS** or **LAPACK**.
- Your implementation:
	- **Does not** have to perform as well as a commercial or highly tuned library.
	- But it **does** have to give **correct answers**.

---

## 2. Deliverables / Format

- You **do not have to** write a formal **final paper**.
- You **might** want to create a **final handout** or short writeup explaining:
	- What you did.
	- How you tested it.
	- Any interesting performance results.

---

## 3. Open Questions

Still under consideration:

- Will there be a **research component**?
	- (for example, you explore a paper, technique, or algorithm variant)

More details to come in class.
